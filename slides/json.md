# Вступ

Цей документ описує граматику JSON та її реалізацію на мові Prolog, Haskell та Ruby.
Розгянуто різні підходи для реалізації програграм які парсить JSON стрічки.
Порівнняно їхні переваги та недоліки.

---

# Опис граматики на прикладі Prolog

Спочатку ми описуємо предикат `parse/2`, який приймає JSON стрічку першим
аргументом та повертає відповідну структуру данних другим аргументом.

```prolog 
parse(String, Data) :-
    atom_chars(String, Chars),
    phrase(json(Data), Chars).
```

Предикат `phrase/2` використовує DCG для опису граматики JSON. Граматика
описана в правилах DCG які відповідають конкретним синтаксичним конструкціям
JSON. Прикладом такого правила є `json/1`:

```prolog
json(String) --> json_string(String).
json(Number) --> json_number(Number).
json(Bool) --> json_bool(Bool).
json(Null) --> json_null(Null).
json(Array) --> json_array(Array).
json(Object) --> json_object(Object).
```

Це правило описує те, що JSON може бути рядком, числом, булевим значенням,
`null`, масивом або об'єктом. Кожне правило викликає відповідний предикат для
парсингу конкретного типу даних.

---

# Definite Clause Grammars (DCG)

Definite Clause Grammars (DCG) - це спеціальний тип правил для опису граматик в
різних програм розбору тексту. 
В мові програмування Prolog `DCG` чудово підходить для парсингу тексту, не
треба працювати з списками, достатньо просто описати граматику і вона буде
працювати.
Синтакс:
- `A --> B` - оператор `-->` використовується для опису правила граматики.

Граматику можна описати як правило. Правила можна вкладати одне в одне. Також
можна додавати багато правил для одного терміналу.

Приклад граматики `as`:
```prolog 
as --> "".
as --> "a", as.
```
Тут ми описали граматику `as` яка може бути пустою або складатися з нуля або більше `a`.
Для отримання результату використовуємо предикат `phrase/2`:

```prolog 
phrase(as, "aaa").
% true
```

---

## Більше синтаксису

Фігурні дужки `{}` використовуються для ізоляції коду в правилах граматики.
Наприклад, ми можемо використовувати `write/1` для виводу тексту в правилах.

```prolog 
as --> { write("foo") }, "a".
% ?- phrase(as, Ls).
% hello
% Ls = [97].
```

Квадратні дужки `[]` використовуються для опису терміналів. Термінал - це символ
або список символів. Наприклад, ми можемо описати правило для парсингу `a`:

```prolog
as --> [97].
```

---

## Стрічки

Стрічки в JSON представлені у подвійних лапках. Перший символ стрічки має бути
`"` та останній `"`. Також ми перетворюємо список атомів у список символів
через предикат `atom_chars/2`.

```prolog
json_string(String) --> ['"'], json_chars(Chars), ['"'], { atom_chars(String, Chars) }.
```

Предикат `json_chars/1` описує символи стрічки. Символи стрічки можуть бути
будь-якими символами крім `"`. Предикат `json_chars/1` викликає сам себе
рекурсивно для кожного символу стрічки поки не буде знайдено символ `"`. 

```prolog
json_chars([]) --> [].
json_chars([Char|Chars]) --> [Char], { Char \= '"' }, json_chars(Chars).
```

---

### Приклад стрічки

Стрічка `"Hello!"` буде описана таким чином. Перший символ стрічки
`"` відповідає правилу `['"']`. Потім ми викликаємо предикат `json_chars/1` для
кожного символу стрічки. Після опису всіх символів стрічки ми викликаємо
правило `['"']` для опису останнього символу стрічки. `atom_chars/2` перетворює
список атомів у список символів. 

```prolog
['"'], json_chars(Chars), ['"'], { atom_chars(String, Chars) }.
```

Описуємов предикат `json_chars([Char|Chars])` для кожного символу стрічки.
Перший символ `H` відповідає правилу `[Char]`, далі ми перевіряємо чи символ не
є `"` за допомогою предикату `Char \= '"'`. Якщо символ не є `"` то ми
викликаємо `json_chars/1` для кожного наступного символу стрічки
(`['e','l','l','o','!', '"']`). Якщо символ є `"` то предикат викликається з
сигнатурою `json_chars([])`.

```prolog
json_chars([]) --> [].
json_chars([Char|Chars]) --> [Char], { Char \= '"' }, json_chars(Chars).
```

---

## Числа

Числа в цій граматиці можуть бути тільки беззнаковими цілими числами. Для опису чисел 

```prolog
json_number(Number) --> json_digits(Digits), { number_chars(Number, Digits) }.
```

Предикат `json_digits/1` описує цифри числа. Цифри можуть бути будь-якими
цифрами від 0 до 9. Предикат `json_digits/1` викликає сам себе рекурсивно для
кожної цифри числа поки не буде знайдено не цифру.

```prolog
json_digits([Digit|Digits]) --> json_digit(Digit), json_digits(Digits).
json_digits([Digit]) --> json_digit(Digit).
json_digit(Digit) --> [Digit], { code_type(Digit, digit) }.
```

Cпочатку ми описуємо правило `json_digits/1` яке викликає `json_digit/1` для
кожної цифри числа. Предикат `json_digit/1` описує себе рекурсивно поки не буде
описане число.


---

### Приклад числа

Число `123` буде описано таким чином. Спочатку викликається правило
`([Digit|Digits])`. Перший символ числа `1` відповідає правилу `[Digit]`, далі
ми перевіряємо чи символ є цифрою за допомогою предикату `code_type(Digit, digit)`. 
Якщо символ є цифрою то ми викликаємо `json_digits/1` для кожної
наступної цифри числа (`['2','3']`). Предикат "зупиняється" коли він не може
більше викликати сам себе рекурсивно. Після опису всіх цифр числа ми викликаємо
правило `json_digits([Digit])`.

```prolog
json_digits([Digit|Digits]) --> json_digit(Digit), json_digits(Digits).
json_digits([Digit]) --> json_digit(Digit).
json_digit(Digit) --> [Digit], { code_type(Digit, digit) }.
```

---

## Константні значення

Константні значення в JSON представлені у вигляді `true`, `false` або `null`. 
Описуючи можна явно вказати конкретні значення.

```prolog
json_bool(true) --> ['t','r','u','e'].
json_bool(false) --> ['f','a','l','s','e'].
json_null(null) --> ['n','u','l','l'].
```

Якщо значення співпадає з одним з константних значень то ми це викликаємо
правило.

---

## Масиви

Масиви в JSON представлені у вигляді `[...]`. Масиви можуть містити будь-яку
кількість елементів. Елементи масиву розділяються комою `,`. Описуючи масиви
ми використовуємо правило `json_array/1` яке обгортає елементи масиву у квадратні дужки
`[...]`. Правило `json_array/1` викликає правило `json_values/1` для елентів масиву.

```prolog
json_array(Array) --> ['['], json_values(Array), [']'].

json_values([Value|Values]) --> json(Value), [','], json_values(Values).
json_values([Value]) --> json(Value).
```

Правило `json_values/1` викликає само себе рекурсивно поки не буде знайдено
останній елемент масиву. `[',']` описує кому яка розділяє елементи
масиву. Кожен елемент масиву описується правилом `json/1`. Якщо після елементу
нема коми то викликається правило `json_values([Value])`.

---

### Приклад масиву

Масив `[1,2,null]` буде описано таким чином. Спочатку викликається правило.
`json_array/1`. Перший символ масиву `[` відповідає правилу `[']`, далі ми 
викликаємо `json_values/1` для кожного елементу масиву (`[1,2,null]`). Кожне
значення описується правилом `json/1`. Коли потрапляємо на останній елемент
викликаємо правило `json_values([Value])`.

---

## Об'єкти

Об'єкти в JSON представлені у вигляді `{...}`. Об'єкти можуть містити будь-яку
кількість пар ключ-значення. Пари ключ-значення розділяються комою `,`.
Описуючи об'єкти ми використовуємо правило `json_object/1` яке обгортає пари
ключ-значення у фігурні дужки `{...}`. Правило `json_object/1` "обгортує"
правило `json_pairs/1` в фігурні дужки. Правило `json_pairs/1` викликає
правило `json_pair/1` для кожної пари ключ-значення, розділяючи їх комами.
Для останньої пари ключ-значення ми викликаємо правило `json_pairs([Pair])`.

```prolog 
json_object(Object) --> ['{'], json_pairs(Object), ['}'].
json_pairs([Pair|Pairs]) --> json_pair(Pair), [','], json_pairs(Pairs).
json_pairs([Pair]) --> json_pair(Pair).
```

Правило `json_pair/1` викликає правило `json_string/1` для ключа та правило
`json/1` для значення. Розділяючи їх двокрапкою `:`.

```prolog
json_pair(Key=Value) --> json_string(Key), [':'], json(Value).
```

---

### Приклад об'єкту

Об'єкт `{ "key": "value" }` буде описано таким чином. Спочатку викликається
правило `json_object/1`. Перший символ об'єкту `{` відповідає правилу `['{']`,
далі ми викликаємо `json_pairs/1` для кожної пари ключ-значення
(`[Key=Value]`). Кожна пара ключ-значення описується правилом `json_pair/1`.
Коли потрапляємо на останню пару викликаємо правило `json_pairs([Pair])`.


---

## Приклади роботи

Для прикладу використаємо SWI-Prolog. Для запуску використовуємо команду
```bash
swipl -s json.pl
```

Використовуємо команду `parse/2`.

```prolog
?- parse('{"key": "value"}', Result).
Result = [key=value]

?- parse('{"key": "value", "key2": "value2"}', Result).
Result = [key=value, key2=value2]

?- parse('[1,2,null]', Result).
Result = [1, 2, null] 

?- parse('{"key": [1,2,null]}', Result).
Result = [key=[1, 2, null]]

?- parse('{"key": {"key2": "value2"}}', Result).
Result = [key=[key2=value2]]
```

---

# Реалізація на Haskell

Було використовано бібліотеку `Parsec` для реалізації парсера.
На відміну від пролог треба було вказувати явно типи даних.
```haskell
data JsonValue
  = String String
  | Number Int
  | Array [JsonValue]
  | Bool Bool
  | Null
  | Object [(String, JsonValue)]
  deriving (Show, Eq)
```

---

# Приклад програми

В порівнянні з Prolog в Haskell менш читабельний і більш багатослівний. Треба
використовувати складні конструкції для опису правил. Наприкладі стрічки

```haskell
jsonString :: Parser JsonValue
jsonString = do
  _ <- char '"'
  str <- many (noneOf "\"")
  _ <- char '"'
  return $ String str
```

Тут використовується `do` нотація. Вона дозволяє використовувати `return` для
повернення значення. Також використовується `many` для повторення дії.
Використовується `noneOf` для визначення кінця стрічки.

Де в мові Prolog значно простіше описано.

---

## Haskell vs Prolog

| Haskell | Prolog |

Код програми на Haskell вийшов аж в цілих 89 рядків, а на Prolog - 35. Це більш
ніж в 2 рази менше, ніж на Haskell. Це можна пояснити тим, що в Haskell більше 
коду використовується для опису типів даних, а в Prolog для опису правил, не
вказуючи явно тип даних, програма сама описує типи даних від реалізації.

Код програми можна знайти в файлі `json.hs`. 

---

# Імперативна мова

Для імперативної мови було використано мову Ruby. Вона була вибрана через
простий синтаксис та легкість написання коду.

Для реалізації було створено клас `Parser` з методом `parse`. При створенні
екзепляру класу `Parser` він приймає стрічку для парсингу і створює змінну
`@index` для відслідковування поточного індексу в стрічці

Метод `parse` повертає зпарсені дані.

```ruby  
class Parser
  def initialize(json_string)
    @json_string = json_string
    @index = 0
  end

  def parse
    # ...
  end
end
```

---

## Json

На відміну від реалізацій Prolog та Haskell, в Імперативній мові треба тримати
поточну позицію в стрічці. Для цього було використано змінну `@index`.

Для операцій зі стрічкою було реалізовано метод `step`. Він збільшує індекc на
одну одиницю. Та метод `current_char`, який повертає поточний символ.

```ruby
class Parser
  def step
    @index += 1
  end

  def current_char
    @json_string[@index]
  end
end
```

Нам треба слідкувати за поточним станом програми і тримати багато факторів в
голові:
- На якому символі ми знаходимось
- Чи потрібно збільшити індекс
- Чи не зламається програма, якщо ми вийдемо за межі стрічки
- Чи потрібно викликати `step` перед викликом `current_char`
- Синтаксичні помилки в стрічці

---

## Парсинг

Для виклику парсеру треба викликати метод `parse`.

```ruby
class Parser
  def parse # Беремо поточний символ і залежно від нього викликаємо метод
    case current_char # Поточний символ
    when '{' # Якщо це '{', то викликаємо метод parse_object
      parse_object
    when '[' # Якщо це '[', то викликаємо метод parse_array
      parse_array
    when '"' # Якщо це '"', то викликаємо метод parse_string
      parse_string
    when 't' # Якщо це 't', то викликаємо метод parse_true
      parse_true
    when 'f' # Якщо це 'f', то викликаємо метод parse_false
      parse_false
    when 'n' # Якщо це 'n', то викликаємо метод parse_null
      parse_null
    when /\d/ # Якщо це число, то викликаємо метод parse_number
      parse_number
    when ' ', "\t", "\r", "\n" # Якщо це пробіл, табуляція, перенос рядка, то викликаємо метод step
      step # Переходимо на наступний символ
      parse # Повторюємо операцію
    end
  end
end
```

---

## Приклад стрічки

Для стрічки використовується цикл `while`, який виконується поки поточний символ не `"`.

```ruby
class Parser
  def parse_string
    step # Переходимо на наступний символ
    string = '' # Створюємо пусту стрічку
    while current_char != '"' # Поки поточний символ не '"'
      string << current_char # Додаємо поточний символ до стрічки
      step # Переходимо на наступний символ
    end
    step # Ми на символі '"', переходимо на наступний символ
    string # Повертаємо стрічку
  end
end
```

Після чого буде повернуто стрічку.
В порівнянні з іншими мовами, в імперативній мові більше коду використовується для обробки
поточного стану програми. В Haskell та Prolog не треба було тримати індекс, а
натомість одразу працювати з граматикою.

---

## Обробка помилок

В імперативній мові під час обробки стрічки можна легко оброблювати помилки.
Наприклад, якщо очікується символ `:`, але поточний якийсь інший, то ми з
легкістю можемо викинути помилку, де вже користувач може її обробити.

```ruby
class Parser
  class SyntaxError < StandardError
  end
end
```

Ми створили клас `SyntaxError`, який наслідується від класу `StandardError`.
На прикладі оброки об'єкту, ми можемо викликати помилку, якщо поточний символ не `:`.

```ruby
class Parser
  def parse_object
    object = {}
    step
    while current_char != '}'
      skip_whitespaces
      key = parse_string
      # Якщо поточний символ не ':', то викидаємо помилку
      raise SyntaxError, "expected ':'" unless current_char == ':' 

      skip_whitespaces
      step
      skip_whitespaces

      value = parse
      object[key] = value
      raise SyntaxError, "expected ',' or '}'" unless current_char == ',' || current_char == '}'

      step if current_char == ','
    end
    step
    object
  end
end
```

---

## Приклад використання

```ruby
parser = Parser.new('{"key": "value"}')
parser.parse # => {"key"=>"value"}

parser = Parser.new('{"key": "value", "key2": "value2"}')
parser.parse # => {"key"=>"value", "key2"=>"value2"}

parser = Parser.new('[1, 2, 3]')]
parser.parse # => [1, 2, 3]
```

Код програми можна знайти в `ruby/parser.rb`

---

# Висновок

В даній роботі було розглянуто різні способи реалізації парсера JSON в мовах
програмування Prolog, Haskell та Ruby. 

Розв'яки задачі досить схожими, але кардинально різними. 
В Haskell ми описували типи і функції, які використовувалися для розбору JSON.
В Ruby ми працювали з конкерними значеннями, декларували класи та методи.  

І тут, на мою думку, виникає проблема. В Ruby ми працюємо з об'єктами, але не з
граматикою. Ми описуємо класи, а над нами вже саму граматику. В цьому випадку
Prolog був би кращим вибором, оскільки потрібно було описати саму граматику і
більше нічого. Це додає простоти та зрозумілості коду. 

---

## Обсяг коду

Обсяг коду в Prolog був менший, ніж в інших мовах. Ось таблиця стічок коду для конкретних мов:

| Haskell | 87  |
| Prolog  | 35  |
| Ruby    | 120 |


Тут очевидна перемога Prolog, але це не означає. І до цього сам синтаксис
порівнянні з Haskell був більш зрозумілим та простим. Менше операторів, а
результар такий же самий.

---

## Складність написання

Найскладнішим було написання коду на Haskell, а найпростішим на Prolog. В
Haskell було багато складних конструкцій та операторів.

Але це додає безпеку на етапі розробки, спочатку декларуємо типи, а потім вже
реалізовуємо і ми можемо бути більш впевнені, що наш код буде працювати. 

Де на Ruby ми маємо додатково протестувати код та перевірку типів. Також варто
зазначити, що в Ruby було дуже легко зробити `debug` коду, імперативна мова
дозволяє це зробити дуже легко. 

В Haskell це було дуже складно, треба тримати в голові цілу програму і
враховувати для програма може зламатися.

Prolog був найпростішим, тут немає ніяких типів, немає ніяких складних конструкцій
і операторів. Тут ми просто описуємо правила, які виконуються. Це було дуже
просто та зрозуміло, через маленький обсяг коду. Легко тримати в голові всю програму.

---

## Використання програми

Використовувати програми на цих мовах було дуже просто. У всіх випадках була
інтерактивна консоль, де ми могли вводити дані та отримувати результат.
В Haskell був `ghc`, в Ruby є `irb` та `swipl` в Prolog.

---

## Корисність задачі

Ця задача була дуже корисною для мене, дізнався що граматики можна описувати за
допомогою простих речень. Ці знання можна використовувати для роботи з
структурованим текстом, наприклад, для розбору HTML та XML. Також це може бути
корисно для розробки інтерпретаторів/компіляторів для мов програмування.

---

## Посилання

* [JSON](http://www.json.org/)
* [SWI-Prolog](http://www.swi-prolog.org/)
* [The Power of Prolog](https://www.youtube.com/@ThePowerOfProlog)
* [DCG](https://www.amzi.com/manuals/amzi/pro/ref_dcg.htm)

---

# Дякую за увагу!

